entity minigame_descriptors;

entity minigame_get_descriptor(string id)
{
	entity e;
	for ( e = minigame_descriptors; e != world; e = e.chain )
		if ( e.netname == id )
			return e;
	return world;
}

// Get relative position of the center of a given tile
vector minigame_tile_pos(string id, float rows, float columns)
{
	float letter = str2chr(substring(id,0,1),0)-'a';
	float number = stof(substring(id,1,-1));
	return eX*(letter+0.5)/columns + eY - eY*(number-0.5)/rows;
}

// Get tile name from a relative position (matches the tile covering a square area)
string minigame_tile_name(vector pos, float rows, float columns)
{
	if ( pos_x < 0 || pos_x > 1 || pos_y < 0 || pos_y > 1 )
		return ""; // no tile
		
	float letter = floor(pos_x * columns);
	float number = floor((1-pos_y) * rows);
	return strcat(chr2str('a'+letter),ftos(number+1));
}

/// For minigame sessions: minigame descriptor object
.entity descriptor;

/// For minigame sessions/descriptors: execute the given event
/// Client events:
/// 	mouse_moved(vector mouse_pos) (return 1 to handle input, 0 to discard)
/// 	mouse_pressed/released(float K_Keycode)(return 1 to handle input, 0 to discard)
/// 	key_pressed/released(float K_Keycode)  (return 1 to handle input, 0 to discard)
/// 		(note: see dpdefs/keycodes.qc for values)
/// 	activate()
/// 	deactivate()
/// Server events:
/// 	start()
/// 	end()
/// 	join(entity player) (return 1 to accept the new player, 0 to discard)
/// 	part(entity player)
.float(entity,string,...)   minigame_event;

// For run-time gameplay entities: Whether to be removed when the game is deactivated
.float minigame_autoclean;

const float MINIG_SF_CREATE = 1;
const float MINIG_SF_PLAYERS = 2;

#include "minigame_nmm.qc"


/**
 * Minigame requirements:
 * SVQC:
 * 	float minigame_event_<id>(entity minigame, string event, ...count)
 * 		see above for an explanation
 * CSQC:
 * 	void minigame_hud_board_<id>(vector pos, vector mySize)
 * 		draws the main game board inside the rectangle defined by pos and mySize
 * 		(That rectangle is expressed in window coordinates)
 * 	void minigame_hud_status_<id>(vector pos, vector mySize)
 * 		draws the game status panel inside the rectangle defined by pos and mySize
 * 		(That rectangle is expressed in window coordinates)
 * 		This panel shows eg scores, captured pieces and so on
 * 	float minigame_event_<id>(entity minigame, string event, ...count)
 * 		see above for an explabation
 * Registration:
 * 	MINIGAME(id,"Name")
 * 		id    (QuakeC symbol) Game identifier, used to find the functions explained above
 * 		"Name"(String)        Human readable name for the game, shown in the UI
 */
#define REGISTERED_MINIGAMES \
	MINIGAME(nmm, "Nine Men's Morris")
