entity minigame_descriptors;

entity minigame_get_descriptor(string id)
{
	entity e;
	for ( e = minigame_descriptors; e != world; e = e.chain )
		if ( e.netname == id )
			return e;
	return world;
}

// Get relative position of the center of a given tile
vector minigame_tile_pos(string id, float rows, float columns)
{
	float letter = str2chr(substring(id,0,1),0)-'a';
	float number = stof(substring(id,1,-1));
	return eX*(letter+0.5)/columns + eY - eY*(number-0.5)/rows;
}

// Get tile name from a relative position (matches the tile covering a square area)
string minigame_tile_name(vector pos, float rows, float columns)
{
	if ( pos_x < 0 || pos_x > 1 || pos_y < 0 || pos_y > 1 )
		return ""; // no tile
		
	float letter = floor(pos_x * columns);
	float number = floor((1-pos_y) * rows);
	return strcat(chr2str('a'+letter),ftos(number+1));
}

/// For minigame sessions: minigame descriptor object
.entity descriptor;

/// For minigame sessions/descriptors: execute the given event
/// Client events:
/// 	mouse_moved(vector mouse_pos) (return 1 to handle input, 0 to discard)
/// 	mouse_pressed/released(float K_Keycode)(return 1 to handle input, 0 to discard)
/// 	key_pressed/released(float K_Keycode)  (return 1 to handle input, 0 to discard)
/// 		(note: see dpdefs/keycodes.qc for values)
/// Server events:
/// 	start()
/// 	end()
/// 	join(entity player) (return 1 to accept the new player, 0 to discard)
/// 	part(entity player)
.float(entity,string,...)   minigame_event;


const float MINIG_SF_CREATE = 1;
const float MINIG_SF_PLAYERS = 2;

#include "minigame_test.qc"

#define REGISTERED_MINIGAMES \
	MINIGAME(test, "Testing")
